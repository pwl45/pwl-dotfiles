#!/bin/sh

if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi
alias epsxe="ePSXe"
alias stata="echo 'exit, clear' | stata-se"
alias please="sudo"
alias vim="nvim"
alias ll='ls -alF'
alias la='eza -al --color=always --group-directories-first'
alias cb='xclip -selection c'
alias cbo='xclip -selection c -out'
# alias l='ls -CF'
# alias debugoff="find -name settings.py -exec sed -i 's/DEBUG\s*=\s*True/DEBUG=false/g' {} \+"
# alias debugon="find -name settings.py -exec sed -i 's/DEBUG\s*=\s*false/DEBUG=True/g' {} \+"
alias wttr="curl wttr.in"
alias stw='st -e zstart "curl wttr.in"'
alias gits="git status"
alias gac="git add -u && git commit -m"
alias gau="git add -u"
alias gdm="git diff origin/master...HEAD"
alias gdmf="git diff origin/master...HEAD --name-only"
gacap(){
    git add -u
    git commit -m $1
    git push
    git rev-parse HEAD | tr -d '\n' | xclip -selection c
}

ggr() {
    git ls-files -z | xargs -0 grep --color=auto "$@"
}

ggri() {
    git ls-files -z | xargs -0 grep -i --color=auto "$@"
}

ggrb() {
    git ls-files -z | grep -z 'BUILD' | xargs -0 grep --color=auto "$@"
}

ggrbi() {
    git ls-files -z | grep -z 'BUILD' | xargs -0 grep --color=auto "$@"
}

ggf() {
    git ls-files | grep --color=auto "$@"
}

gco(){
    if [ $# -eq 0 ]; then
        echo "Error: Please provide at least one filename"
        echo "Usage: gco <filename> [<filename2> ...]"
        return 1
    fi
    git checkout --ours "$@" ; git add "$@"
}
gct(){
    if [ $# -eq 0 ]; then
        echo "Error: Please provide at least one filename"
        echo "Usage: gct <filename> [<filename2> ...]" 
        return 1
    fi
    git checkout --theirs "$@" ; git add "$@"
}

replecho(){
    echo -e "\e[1A\e[K$@"
}
alias curlpj='curl -X POST -H "Content-Type: application/json"'
# sepl OLD NEW [OPTIONS] [FILE...]
# example: 
# sepl old-string new-string -i file.txt
# =>
# sed "s/old-string/new-string/g" -i file.txt
# except with a non-printable character used as the sed delimiter instead of /
sepl(){
    # \x7 is the ASCII value 7, a non-printable character. 
    # This means it is a character that will not occurr in any normal string we're using for sed
    SEP=$(echo -e '\x7')

    OLD=$1 # pattern to replace - first argument
    NEW=$2 # pattern to replace with - second argument

    # shift all arguments down two: 
    shift; shift
    # now $@ (all arguments to sepl) is all arguments except the first two

    # run sed to replace old with new using non-printable delimiter
    # pass $@ (now all arguments except first two) to sed normally
    sed "s${SEP}${OLD}${SEP}${NEW}${SEP}g" $@
}

alias so="source $HOME/.zshrc"
alias sa="source $HOME/.config/aliasrc"
alias va="vim $HOME/.config/aliasrc"
alias ev="vim $MYVIMRC"
alias std="st -d . >/dev/null 2>/dev/null &"
alias duh="du -h"
alias awksum="awk '{s+=\$1} END {print s}'"
alias awkfc="awk -F ','"
alias awklast="awk '{print \$NF}'"

unalias gcb 2>/dev/null || true
gcb(){
    git branch | sed 's/^\*\?\s*//g' | fzf | xargs -r git checkout
}

gbb(){
    # Check if a branch name was provided
    if [ -z "$1" ]; then
        echo "Error: Please provide a branch name"
        echo "Usage: gbb <new-branch-name>"
        return 1
    fi

    # Store the new branch name
    new_branch="$1"

    # Get the default branch name
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
    
    if [ $? -ne 0 ]; then
        echo "Error: Could not determine default branch. Are you in a git repository?"
        return 1
    fi

    # Checkout the default branch
    echo "Checking out ${default_branch}..."
    git checkout "$default_branch"
    if [ $? -ne 0 ]; then
        echo "Error: Failed to checkout ${default_branch}"
        return 1
    fi

    # Pull latest changes
    echo "Pulling latest changes..."
    git pull
    if [ $? -ne 0 ]; then
        echo "Error: Failed to pull latest changes"
        return 1
    fi

    # Create and checkout new branch
    echo "Creating and checking out new branch: ${new_branch}"
    git checkout -b "$new_branch"
    if [ $? -ne 0 ]; then
        echo "Error: Failed to create new branch ${new_branch}"
        return 1
    fi

    echo "Successfully created new branch '${new_branch}' from latest ${default_branch}"
}

alias gau="git add -u"
alias glap="git log --patch -1"
alias glp="git log --patch"
alias gcm="git commit -m"
alias ga="git add"
alias gp="git push"
alias gd="git diff"
alias ggm='git status -uno'
alias gres='git checkout $(git branch --show-current) --'
alias chx="echo 'chimken' && chmod 755"
alias fzf='fzf --reverse --prompt=">> "'
alias q='qutebrowser'
alias z='zathura'
alias gr='grep -r'
gccb(){
    cmd="git clone $( xclip -selection c -out )"
    echo "$cmd"
    eval $cmd && echo "$cmd" >> .zhistory
}
alias G='gccb'
alias pyi='python3 -i'
alias py3='python3'
alias ec='devour emacsclient -c'

# nice things for movement
alias emom="cd $HOME/qmk_firmware/keyboards/momoka_ergo/keymaps/momoka_ergo_beta && $EDITOR keymap.c"
alias ered="cd $HOME/qmk_firmware/keyboards/redox/keymaps/redox_pwl45/ && $EDITOR keymap.c"
alias eava="cd $HOME/qmk_firmware/keyboards/avalanche/v4/keymaps/avalanch_pwl45/ && $EDITOR keymap.c"
alias ths="cd $HOME/thesis/git/thesis-document"
alias tho="cd $HOME/thesis/git/otree"
alias thl="cd $HOME/thesis/git/luka"
alias thc="cd $HOME/thesis/git/cat"
alias ekm="eava"
alias qc="qmk compile"
alias qf="qmk flash && xset r rate 300 50"
alias fm="qmk flash && echo '\n----------DONE----------\n' && qmk flash && xset r rate 300 50"
alias cdd='cd $HOME && cd'
alias fzk="ps aux | fzf | awk '{print \$2}' | xargs -r kill"
alias dkill="ps aux | dmenu -l 56 | awk '{print \$2}' | xargs -r kill"
alias cal3="cal -3"
alias calf="cal -A 3"
alias calb="cal -B 3"
alias mkc='mkdir-cd'
alias ggh="git rev-parse HEAD | tr -d '\n' | cb"

alias hsf='home-manager switch --flake $HOME/pwl-dotfiles'
alias snrs='sudo nixos-rebuild switch'
alias ns='nix-shell --run zsh'
lsd(){
 ls -d $@ */
}

mkdir-cd(){
    mkdir $1 && cd $1
}
# alias fixaudio="pactl set-card-profile 0 output:analog-stereo && pactl set-card-profile 0 input:analog-stereo"

zf() { fd -HI ".*.pdf" | fzf  | xargs -d '\n' -r zathura }
vf() {
  local file
  file=$(fd -HI | fzf) || return
  [[ -n "$file" ]] && {
    print -s "$EDITOR $file"
    $EDITOR "$file"
  }
}
# gf() { 
#     file=$( fd -H | fzf ) 
#     # read program
#     read -sk char
#     echo $char
#     case $char in
# 	v)
# 	    program="nvim"
# 	    ;;
# 	z)
# 	    program="zathura"
# 	    ;;
# 	m)
# 	    program="mpv"
# 	    ;;
# 	e)
# 	    program="emacs"
# 	    ;;
# 	c)
# 	    cd "$file"
# 	    return 0
# 	    ;;
# 	*)
# 	    echo "Usage: $0 {start|stop|restart|status}"
# 	    return 1
# 	    ;;
#     esac
#     echo $program $file

#     $program $file
# }

ef() { fd -H | fzf  | xargs -r emacs }
vff() { fd -H . $HOME | fzf  | xargs -r $EDITOR }
# ccv() { tmp=$(fd -H -t d . $HOME | fzf) && cd $tmp }
vfc() { tmp=$( fzf ) && cd $( dirname "$tmp" ) && basename $tmp | xargs -r $EDITOR }
# TODO: Refactor these 
vffc() { tmpcmd=$FZF_DEFAULT_COMMAND; FZF_DEFAULT_COMMAND='fd -H . $HOME'; vfc ; FZF_DEFAULT_COMMAND=$tmpcmd }
cv() { tmp=$(fd -H -t d | fzf) && cd $tmp }
ccv() { tmp=$(fd -H -t d . $HOME | fzf) && cd $tmp }

cdl() {
    \cd $1 && echo $PWD >> $HOME/.shell-dir
    echo "cd $1" >> $HISTFILE
}
alias cd='cdl'
alias mdcodecat='python3 $HOME/pwl-dotfiles/mdcodecat.py'

cdg(){
    tmp=$( tail -n 10000 $HOME/.shell-dir | awk '!seen[$0]++' | tac | fzf )
    if [ ! -z $tmp ]; then
	cdl $tmp
    fi
}

cdlr(){
    tmp=$( fd -H -t d | fzf )
    if [ ! -z $tmp ]; then
	cdl $tmp
    fi
}

bak() {
    if [ $# -eq 0 ]; then
        echo "Usage: bak filename"
        return 1
    fi
    
    local filename="$1"
    if [ -e "$filename" ]; then
        mv "$filename" "${filename}.bak"
        echo "Moved $filename to ${filename}.bak"
    else
        echo "Error: $filename does not exist"
        return 1
    fi
}

rerun() {
    killall $1 && $1
}

dwmdo(){
    echo $1 > /tmp/dwm.fifo
}

lview(){
    pdflatex $1 && zathura $( basename $1 ).pdf
}

ccc(){
    file=$1
    if [[ $file = *.c ]]; then
	# remove smallest suffix matching .c from filename
	# (there can only be one suffix matching .c)
	cmd="gcc ${file} -o ${file%.c}"
	echo $cmd
	eval $cmd
    else
	cmd="gcc ${file}.c -o ${file}"
	echo $cmd
	eval $cmd
    fi
}

docgrep(){
    docker ps -a | grep "$1" | awk '{print $1}'
}

# Function to run an existing container and start a bash shell
docrun() {
    local container_id=$(docgrep "$@" | head -n 1)
    if [ -n "$container_id" ]; then
        echo "Starting container $container_id"
        docker start "$container_id"
        docker exec -it "$container_id" /bin/bash
    else
        echo "No matching container found"
    fi
}

docip(){
    local container_id=$(docgrep "$@" | head -n 1)
    if [ -n "$container_id" ]; then
	docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$container_id"
    else
        echo "No matching container found"
    fi

}


# Function to exec into an existing container with a bash shell
docex() {
    local container_id=$(docgrep "$1" | head -n 1)
    if [ -n "$container_id" ]; then
        if [ $# -gt 1 ]; then
            echo "Executing command in container $container_id"
            docker exec -it "$container_id" /bin/bash -c "${@:2}"
        else
            echo "Executing bash in container $container_id"
            docker exec -it "$container_id" /bin/bash
        fi
    else
        echo "No matching container found"
    fi
}

docpurge() {
    local container_id=$(docgrep "$@" | head -n 1)
    local prune_images=false

    # Check if the --prune flag is provided
    if [[ "$1" == "--prune" ]]; then
        prune_images=true
        shift  # Remove the --prune argument
        container_id=$(docgrep "$@" | head -n 1)
    fi

    if [ -n "$container_id" ]; then
        echo "Purging container $container_id and associated resources"
        
        # Stop the container if it's running
        docker stop "$container_id" 2>/dev/null

        # Remove the container
        docker rm -f "$container_id"

        # Get the image ID associated with the container
        local image_id=$(docker inspect --format='{{.Image}}' "$container_id" 2>/dev/null)
        
        if [ -n "$image_id" ]; then
            # Remove the image
            docker rmi -f "$image_id"
            
            # Remove any dangling images if --prune was specified
            if $prune_images; then
                echo "Removing dangling images..."
                docker image prune -f
            fi
        else
            echo "Associated image not found or already removed"
        fi

        echo "Purge complete"
    else
        echo "No matching container found"
    fi
}

# Helper function for s3 archive operations
s3_archive_op() {
    local profile="${AWS_PROFILE:-default}"
    local url=""
    local op=$1
    local usage_cmd=$2

    # Parse arguments
    while [[ $# -gt 2 ]]; do
        case "$3" in
            --profile)
                profile=$4
                shift 2
                ;;
            *)
                url="$3"
                shift
                ;;
        esac
    done

    # Check if URL is provided
    if [ -z "$url" ]; then
        echo "Error: No URL provided"
        echo "Usage: $usage_cmd [--profile aws_profile] s3_url"
        return 1
    fi

    # Prepend s3:// if not already present
    if [[ ! "$url" =~ ^s3:// ]]; then
        url="s3://$url"
    fi

    aws --profile $profile s3 cp "$url" - | tar $op
}

s3tz() {
    s3_archive_op "tz" "s3tz" "$@"
}

s3xz() {
    s3_archive_op "xz" "s3xz" "$@"
}


swap(){echo $1 $2; fl=$(mktemp); mv $1 $fl; mv $2 $1; mv $fl $2}

grep_to_from(){
    start_pattern=$1
    shift
    end_pattern=$1
    shift
    awk -v print_start="$start_pattern" -v print_end="$end_pattern" '$0 ~ print_start{doprint=1} doprint{print} $0 ~ print_end{doprint=0}' $@
}
# ZLE Bindings are annoying
function vf-z() { vf ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N vf-z
bindkey '^f' vf-z

function zf-z() { zf ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N zf-z
bindkey '^g' zf-z


function cdg-z() { cdg ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N cdg-z
bindkey '^p' cdg-z

function cdlr-z() { cdlr ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N cdlr-z

function gccb-z(){zle reset-prompt; gccb ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N gccb-z
function gcb-z(){zle reset-prompt; gcb ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N gcb-z

# remap control enter to do autosuggest
bindkey '[13;5u' autosuggest-execute

function bk-z() { cd .. ; zle reset-prompt; zle redisplay; zle-keymap-select}
zle -N bk-z
bindkey '^h' bk-z

bindkey -a H beginning-of-line
bindkey -a L end-of-line

### Make ctrl a, ctrl e, and ctrl k do what they do in emacs
# Bind Ctrl-a to move to the beginning of the line in vi mode
bindkey -M viins '^A' beginning-of-line
bindkey -M vicmd '^A' beginning-of-line

# Bind Ctrl-e to move to the end of the line in vi mode
bindkey -M viins '^E' end-of-line
bindkey -M vicmd '^E' end-of-line

# Bind Ctrl-k to kill the line from the cursor to the end in vi mode
bindkey -M viins '^K' kill-line
source "$HOME/.config/grab.sh"
source "$HOME/.config/unroll.sh"

